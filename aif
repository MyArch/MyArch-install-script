# !/bin/bash
#
# Architect Installation Framework (version 2.0 beta - 11-Feb-2016)
#
# Written by Carl Duff for Architect Linux
#
# This program is free software, provided under the GNU General Public License
# as published by the Free Software Foundation. So feel free to copy, distribute,
# or modify it as you wish.
#



######################################################################
##																	##
##                   Installer Variables							##
##																	##
######################################################################

# Temporary files to store menu selections
ANSWER="/tmp/.aif"				# Basic menu selections
PACKAGES="/tmp/.pkgs"			# Packages to install
BTRFS_OPTS="/tmp/.btrfs_opts"	# BTRFS mount options

# Save retyping
VERSION="Architect Installation Framework (beta)"

# Installation
KDE_INSTALLED=0      				# Has KDE been installed? Used for display manager option
GNOME_INSTALLED=0    				# Has Gnome been installed? Used for display manager option
LXDE_INSTALLED=0     				# Has LXDE been installed? Used for display manager option
LXQT_INSTALLED=0            		# Has LXQT been installed? Used for display manager option
DM_INSTALLED=0       				# Has a display manager been installed?
COMMON_INSTALLED=0   				# Has the common-packages option been taken?
DM_INST="/tmp/.dm"					# Which DMs have been installed with DEs?
NM_INSTALLED=0       				# Has a network connection manager been installed and enabled?
AXI_INSTALLED=0             		# Have the ALSA, Xorg, and xf86-input packages been installed?
BOOTLOADER="n/a"      				# Which bootloader has been installed?
KEYMAP="us"          				# Virtual console keymap. Default is "us"
XKBMAP="us"      	    			# X11 keyboard layout. Default is "us"
ZONE=""               				# For time
SUBZONE=""            				# For time
LOCALE="en_US.UTF-8"  				# System locale. Default is "en_US.UTF-8"
KERNEL=0                			# Installed Kernel. 1 = linux, 2 = linux-lts, 3 = both
GRAPHIC_CARD=""						# graphics card
INTEGRATED_GC=""					# Integrated graphics card for NVIDIA
NVIDIA_INST=0         				# Indicates if NVIDIA proprietary driver has been installed
NVIDIA=""							# NVIDIA driver(s) to install depending on kernel(s)
VB_MOD=""							# Virtualbox guest modules to install depending on kernel(s)
SHOW_ONCE=0           				# Show de_wm information only once

# Architecture
ARCHI=`uname -m`     				# Display whether 32 or 64 bit system
SYSTEM="Unknown"     				# Display whether system is BIOS or UEFI. Default is "unknown"
ROOT_PART=""          				# ROOT partition
UEFI_PART=""						# UEFI partition
UEFI_MOUNT=""         				# UEFI mountpoint

# Menu highlighting (automated step progression)
HIGHLIGHT=0           				# Highlight items for Main Menu
HIGHLIGHT_SUB=0	    				# Highlight items for submenus
SUB_MENU=""           				# Submenu to be highlighted

# Logical Volume Management
LVM=0                   			# Logical Volume Management Detected?
LUKS=0                  			# Luks Detected?
LVM_ROOT=0              			# LVM used for Root?
LVM_SEP_BOOT=0          			# 1 = Seperate /boot, 2 = seperate /boot & LVM
LVM_DISABLE=0           			# Option to allow user to deactive existing LVM
LVM_VG=""               			# Name of volume group to create
LVM_VG_MB=0             			# MB remaining of VG
LVM_LV_NAME=""          			# Name of LV to create
LV_SIZE_INVALID=0       			# Is LVM LV size entered valid?
VG_SIZE_TYPE=""         			# Is VG in Gigabytes or Megabytes?

# Installation
MOUNTPOINT="/mnt"       			# Installation
BTRFS=0                     		# BTRFS used? "1" = btrfs alone, "2" = btrfs + subvolume(s)
BTRFS_MNT=""                		# used for syslinux where /mnt is a btrfs subvolume
F2FS=0								# F2FS used? "1" = yes.

# Language Support
CURR_LOCALE="en_US.UTF-8"   		# Default Locale
FONT=""                     		# Set new font if necessary

# Edit Files
FILE=""                     		# Which file is to be opened?
FILE2=""							# Which second file is to be opened?

######################################################################
##																	##
##                        Core Functions							##
##																	##
######################################################################

# Add locale on-the-fly and sets source translation file for installer
select_language() {
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Select Language " --menu "\nLanguage / sprache / taal / språk / lingua / idioma / nyelv / língua" 0 0 4 \
 	"1" $"English		(en)" 2>${ANSWER}
#	"2" $"Italian 		(it)" \
# 	"3" $"Russian 		(ru)" \
# 	"4" $"Turkish 		(tr)" \
# 	"5" $"Dutch 		(nl)" \
# 	"6" $"Greek 		(el)" \
# 	"7" $"Danish 		(da)" \
# 	"8" $"Hungarian 	(hu)" \
# 	"9" $"Portuguese 	(pt)" \
#   "10" $"German	 	(de)" \
#   "11" $"French		(fr)" \
#   "12" $"Polish		(pl)" 2>${ANSWER}

	case $(cat ${ANSWER}) in
        "1") source /aif-dev-master/english.trans
             CURR_LOCALE="en_US.UTF-8"
             ;;
#        "2") source /aif-dev-master/italian.trans
#             CURR_LOCALE="it_IT.UTF-8"
#             ;; 
#        "3") source /aif-dev-master/russian.trans
#             CURR_LOCALE="ru_RU.UTF-8"
#             FONT="LatKaCyrHeb-14.psfu"
#             ;;
#        "4") source /aif-dev-master/turkish.trans
#             CURR_LOCALE="tr_TR.UTF-8"
#             FONT="LatKaCyrHeb-14.psfu"
#             ;;
#        "5") source /aif-dev-master/dutch.trans
#             CURR_LOCALE="nl_NL.UTF-8"
#             ;;             
#        "6") source /aif-dev-master/greek.trans
#             CURR_LOCALE="el_GR.UTF-8"
#             FONT="iso07u-16.psfu"       
#             ;;
#        "7") source /aif-dev-master/danish.trans
#             CURR_LOCALE="da_DK.UTF-8"
#             ;;   
#        "8") source /aif-dev-master/hungarian.trans
#             CURR_LOCALE="hu_HU.UTF-8"
#             FONT="lat2-16.psfu"
#             ;;
#        "9") source /aif-dev-master/portuguese.trans
#             CURR_LOCALE="pt_BR.UTF-8"    
#             ;;      
#       "10") source /aif-dev-master/german.trans
#             CURR_LOCALE="de_DE.UTF-8"
#             ;;
#       "11") source /aif-dev-master/french.trans
#             CURR_LOCALE="fr_FR.UTF-8"
#             ;;
#       "12") source /aif-dev-master/polish.trans
#             CURR_LOCALE="pl_PL.UTF-8"
#             FONT="latarcyrheb-sun16"
#             ;;
          *) exit 0
             ;;
    esac
        
    # Generate the chosen locale and set the language
    sed -i "s/#${CURR_LOCALE}/${CURR_LOCALE}/" /etc/locale.gen
    locale-gen >/dev/null 2>&1
    export LANG=${CURR_LOCALE}
    [[ $FONT != "" ]] && setfont $FONT
}



# Check user is root, and that there is an active internet connection
# Seperated the checks into seperate "if" statements for readability.
check_requirements() {
	
  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ChkTitle" --infobox "$_ChkBody" 0 0
  sleep 2
  
  if [[ `whoami` != "root" ]]; then
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_RtFailTitle" --infobox "$_RtFailBody" 0 0
     sleep 2
     exit 1
  fi
  
  if [[ ! $(ping -c 1 google.com) ]]; then
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ConFailTitle" --infobox "$_ConFailBody" 0 0
     sleep 2
     exit 1
  fi
  
  # This will only be executed where neither of the above checks are true.
  # The error log is also cleared, just in case something is there from a previous use of the installer.
  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ReqMetTitle" --infobox "$_ReqMetBody" 0 0
  sleep 2   
  clear
  echo "" > /tmp/.errlog
  pacman -Syy

}

# Adapted from AIS. Checks if system is made by Apple, whether the system is BIOS or UEFI,
# and for LVM and/or LUKS.
id_system() {
	
    # Apple System Detection
    if [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Inc.' ]] || [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Computer, Inc.' ]]; then
      modprobe -r -q efivars || true  # if MAC
    else
      modprobe -q efivarfs            # all others
    fi
    
    # BIOS or UEFI Detection
    if [[ -d "/sys/firmware/efi/" ]]; then
      # Mount efivarfs if it is not already mounted
      if [[ -z $(mount | grep /sys/firmware/efi/efivars) ]]; then
        mount -t efivarfs efivarfs /sys/firmware/efi/efivars
      fi
      SYSTEM="UEFI"
    else
      SYSTEM="BIOS"
    fi
         
    # Encryption (LUKS) Detection
    [[ $(lsblk -o TYPE | grep "crypt") == "" ]] && LUKS=0 || LUKS=1

}   
 

# Adapted from AIS. An excellent bit of code!
arch_chroot() {
    arch-chroot $MOUNTPOINT /bin/bash -c "${1}"
}  

# If there is an error, display it, clear the log and then go back to the main menu (no point in continuing).
check_for_error() {

 if [[ $? -eq 1 ]] && [[ $(cat /tmp/.errlog | grep -i "error") != "" ]]; then
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$(cat /tmp/.errlog)" 0 0
    echo "" > /tmp/.errlog
    main_menu_online
 fi
   
}

# Ensure that a partition is mounted
check_mount() {

    if [[ $(lsblk -o MOUNTPOINT | grep ${MOUNTPOINT}) == "" ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$_ErrNoMount" 0 0
       main_menu_online
    fi

}

# Ensure that Arch has been installed
check_base() {

    if [[ ! -e ${MOUNTPOINT}/etc ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$_ErrNoBase" 0 0
        main_menu_online
    fi
    
}

# Simple code to show devices / partitions.
show_devices() {
     lsblk -o NAME,MODEL,TYPE,FSTYPE,SIZE,MOUNTPOINT | grep -v "loop" | grep -v "rom" | grep -v "arch_airootfs" > /tmp/.devlist
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevShowTitle" --textbox /tmp/.devlist 0 0
}

######################################################################
##																	##
##                 Configuration Functions							##
##																	##
######################################################################


# Adapted from AIS. Added option to allow users to edit the mirrorlist.
configure_mirrorlist() {

# Generate a mirrorlist based on the country chosen.	
mirror_by_country() {

 COUNTRY_LIST=""
 countries_list=("AU_Australia AT_Austria BY_Belarus BE_Belgium BR_Brazil BG_Bulgaria CA_Canada CL_Chile CN_China CO_Colombia CZ_Czech_Republic DK_Denmark EE_Estonia FI_Finland FR_France DE_Germany GB_United_Kingdom GR_Greece HU_Hungary IN_India IE_Ireland IL_Israel IT_Italy JP_Japan KZ_Kazakhstan KR_Korea LV_Latvia LU_Luxembourg MK_Macedonia NL_Netherlands NC_New_Caledonia NZ_New_Zealand NO_Norway PL_Poland PT_Portugal RO_Romania RU_Russia RS_Serbia SG_Singapore SK_Slovakia ZA_South_Africa ES_Spain LK_Sri_Lanka SE_Sweden CH_Switzerland TW_Taiwan TR_Turkey UA_Ukraine US_United_States UZ_Uzbekistan VN_Vietnam")

 for i in ${countries_list}; do
     COUNTRY_LIST="${COUNTRY_LIST} ${i} -"
 done
	
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorCntryTitle" --menu "$_MirrorCntryBody" 0 0 16 ${COUNTRY_LIST} 2>${ANSWER} || prep_menu
 COUNTRY_CODE=$(cat ${ANSWER} |sed 's/_.*//')

 URL="https://www.archlinux.org/mirrorlist/?country=${COUNTRY_CODE}&use_mirror_status=on"
 MIRROR_TEMP=$(mktemp --suffix=-mirrorlist)

 # Get latest mirror list and save to tmpfile
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorGenTitle" --infobox "$_MirrorGenBody" 0 0
  
 curl -so ${MIRROR_TEMP} ${URL} 2>/tmp/.errlog
 check_for_error
 sed -i 's/^#Server/Server/g' ${MIRROR_TEMP}
 nano ${MIRROR_TEMP}

 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --yesno "$_MirrorGenQ" 0 0

 if [[ $? -eq 0 ]];then
    mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig
    mv -f ${MIRROR_TEMP} /etc/pacman.d/mirrorlist
    chmod +r /etc/pacman.d/mirrorlist
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --infobox "$_DoneMsg" 0 0
	sleep 2
 else
    prep_menu
 fi
}

dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorlistTitle" \
    --menu "$_MirrorlistBody" 0 0 5 \
	"1" "$_MirrorbyCountry" \
	"2" "$_MirrorEdit" \
	"3" "$_MirrorRank" \
	"4" "$_MirrorRestore" \
	"5" "$_Back" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") mirror_by_country
             ;;
        "2") nano /etc/pacman.d/mirrorlist
             ;;
        "3") dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorRankTitle" --infobox "$_MirrorRankBody" 0 0
             cp -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup
             rankmirrors -n 10 /etc/pacman.d/mirrorlist.backup > /etc/pacman.d/mirrorlist 2>/tmp/.errlog
             check_for_error
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --infobox "$_DoneMsg" 0 0
			 sleep 2
             ;;
         "4") if [[ -e /etc/pacman.d/mirrorlist.orig ]]; then       
				 mv -f /etc/pacman.d/mirrorlist.orig /etc/pacman.d/mirrorlist
				 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --msgbox "$_MirrorRestDone" 0 0
		      else
		         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorNoneTitle" --msgbox "$_MirrorNoneBody" 0 0
		      fi
             ;;
          *) prep_menu
             ;;
    esac  	

    configure_mirrorlist
}

# virtual console keymap
set_keymap() { 
	
	KEYMAPS=""
    for i in $(ls -R /usr/share/kbd/keymaps | grep "map.gz" | sed 's/\.map.gz//g' | sort); do
        KEYMAPS="${KEYMAPS} ${i} -"
    done
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_KeymapTitle" \
    --menu "$_KeymapBody" 20 40 16 ${KEYMAPS} 2>${ANSWER} || prep_menu 
    KEYMAP=$(cat ${ANSWER})
    
	loadkeys $KEYMAP 2>/tmp/.errlog
    check_for_error

    echo -e "KEYMAP=${KEYMAP}\nFONT=${FONT}" > /tmp/vconsole.conf
  }

# Set keymap for X11
 set_xkbmap() {
	 
	XKBMAP_LIST=""
	keymaps_xkb=("af_Afghani al_Albanian am_Armenian ara_Arabic at_German-Austria az_Azerbaijani ba_Bosnian bd_Bangla be_Belgian bg_Bulgarian br_Portuguese-Brazil bt_Dzongkha bw_Tswana by_Belarusian ca_French-Canada cd_French-DR-Congo ch_German-Switzerland cm_English-Cameroon cn_Chinese cz_Czech de_German dk_Danishee_Estonian epo_Esperanto es_Spanish et_Amharic fo_Faroese fi_Finnish fr_French gb_English-UK ge_Georgian gh_English-Ghana gn_French-Guinea gr_Greek hr_Croatian hu_Hungarian ie_Irish il_Hebrew iq_Iraqi ir_Persian is_Icelandic it_Italian jp_Japanese ke_Swahili-Kenya kg_Kyrgyz kh_Khmer-Cambodia kr_Korean kz_Kazakh la_Lao latam_Spanish-Lat-American lk_Sinhala-phonetic lt_Lithuanian lv_Latvian ma_Arabic-Morocco mao_Maori md_Moldavian me_Montenegrin mk_Macedonian ml_Bambara mm_Burmese mn_Mongolian mt_Maltese mv_Dhivehi ng_English-Nigeria nl_Dutch no_Norwegian np_Nepali ph_Filipino pk_Urdu-Pakistan pl_Polish pt_Portuguese ro_Romanian rs_Serbian ru_Russian se_Swedish si_Slovenian sk_Slovak sn_Wolof sy_Arabic-Syria th_Thai tj_Tajik tm_Turkmen tr_Turkish tw_Taiwanese tz_Swahili-Tanzania ua_Ukrainian us_English-US uz_Uzbek vn_Vietnamese za_English-S-Africa")
    
	for i in ${keymaps_xkb}; do
        XKBMAP_LIST="${XKBMAP_LIST} ${i} -"
    done
	
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_XkbmapTitle" --menu "$_XkbmapBody" 0 0 16 ${XKBMAP_LIST} 2>${ANSWER} || config_base_menu
    XKBMAP=$(cat ${ANSWER} |sed 's/_.*//')
    echo -e "Section "\"InputClass"\"\nIdentifier "\"system-keyboard"\"\nMatchIsKeyboard "\"on"\"\nOption "\"XkbLayout"\" "\"${XKBMAP}"\"\nEndSection" > /tmp/00-keyboard.conf
 
}

# locale array generation code adapted from the Manjaro 0.8 installer
set_locale() {

  LOCALES=""	
  for i in $(cat /etc/locale.gen | grep -v "#  " | sed 's/#//g' | sed 's/ UTF-8//g' | grep .UTF-8); do
      LOCALES="${LOCALES} ${i} -"
  done

  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LocateTitle" --menu "$_localeBody" 0 0 16 ${LOCALES} 2>${ANSWER} || config_base_menu 
  LOCALE=$(cat ${ANSWER})
  
  echo "LANG=\"${LOCALE}\"" > ${MOUNTPOINT}/etc/locale.conf
  sed -i "s/#${LOCALE}/${LOCALE}/" ${MOUNTPOINT}/etc/locale.gen 2>/tmp/.errlog
  arch_chroot "locale-gen" >/dev/null 2>>/tmp/.errlog
  check_for_error
}

# Set Zone and Sub-Zone
set_timezone() {

    ZONE=""
    for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "/" | sed "s/\/.*//g" | sort -ud); do
      ZONE="$ZONE ${i} -"
    done
    
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_TimeZTitle" --menu "$_TimeZBody" 0 0 10 ${ZONE} 2>${ANSWER} || config_base_menu
     ZONE=$(cat ${ANSWER}) 
    
     SUBZONE=""
     for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "${ZONE}/" | sed "s/${ZONE}\///g" | sort -ud); do
        SUBZONE="$SUBZONE ${i} -"
     done
         
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_TimeSubZTitle" --menu "$_TimeSubZBody" 0 0 11 ${SUBZONE} 2>${ANSWER} || config_base_menu
     SUBZONE=$(cat ${ANSWER}) 
    
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --yesno "$_TimeZQ ${ZONE}/${SUBZONE} ?" 0 0 
     
     if [[ $? -eq 0 ]]; then
        arch_chroot "ln -s /usr/share/zoneinfo/${ZONE}/${SUBZONE} /etc/localtime" 2>/tmp/.errlog
        check_for_error
     else
        config_base_menu
     fi
}

set_hw_clock() {
	
   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_HwCTitle" \
    --menu "$_HwCBody" 0 0 2 \
 	"1" "$_HwCUTC" \
	"2" "$_HwLocal" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") arch_chroot "hwclock --systohc --utc"  2>/tmp/.errlog
             ;;
        "2") arch_chroot "hwclock --systohc --localtime" 2>/tmp/.errlog
             ;;
          *) config_base_menu
             ;;
     esac	
     
     check_for_error
}

# Adapted from AIS. As with some other functions, decided that keeping the numbering for options
# was worth repeating portions of code.
generate_fstab() {

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_FstabTitle" \
    --menu "$_FstabBody" 0 0 3 \
	"1" "$_FstabDev" \
	"2" "$_FstabLabel" \
	"3" "$_FstabUUID" 2>${ANSWER}

    case $(cat ${ANSWER}) in
        "1") genfstab -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             ;;
        "2") genfstab -L -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             ;;
        "3") if [[ $SYSTEM == "UEFI" ]]; then
                genfstab -t PARTUUID -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             else 
                genfstab -U -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             fi
             ;;
          *) config_base_menu
             ;;
    esac

    check_for_error

    [[ -f ${MOUNTPOINT}/swapfile ]] && sed -i "s/\\${MOUNTPOINT}//" ${MOUNTPOINT}/etc/fstab

}

# Adapted from AIS.
set_hostname() {

   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_HostNameTitle" --inputbox "$_HostNameBody" 0 0 "arch" 2>${ANSWER} || config_base_menu
   HOST_NAME=$(cat ${ANSWER})

   echo "$HOST_NAME" > ${MOUNTPOINT}/etc/hostname 2>/tmp/.errlog
   check_for_error
   echo -e "#<ip-address>\t<hostname.domain.org>\t<hostname>\n127.0.0.1\tlocalhost.localdomain\tlocalhost\t${HOST_NAME}\n::1\tlocalhost.localdomain\tlocalhost\t${HOST_NAME}" > ${MOUNTPOINT}/etc/hosts
}

# Adapted and simplified from the Manjaro 0.8 and Antergos 2.0 installers
set_root_password() {

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassRtTitle" --clear --insecure --passwordbox "$_PassRtBody" 0 0 2> ${ANSWER} || config_user_menu
    PASSWD=$(cat ${ANSWER})
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassRtTitle" --clear --insecure --passwordbox "$_PassRtBody2" 0 0 2> ${ANSWER} || config_user_menu
    PASSWD2=$(cat ${ANSWER})
    
    if [[ $PASSWD == $PASSWD2 ]]; then 
       echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
       arch_chroot "passwd root" < /tmp/.passwd >/dev/null 2>/tmp/.errlog
       rm /tmp/.passwd
       check_for_error
    else
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassRtErrTitle" --msgbox "$_PassRtErrBody" 0 0
       set_root_password
    fi

}

# Originally adapted from the Antergos 2.0 installer
create_new_user() {

        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NUsrTitle" --inputbox "$_NUsrBody" 0 0 "" 2>${ANSWER} || config_user_menu
        USER=$(cat ${ANSWER})
        
        # Loop while user name is blank, has spaces, or has capital letters in it.
         while [[ ${#USER} -eq 0 ]] || [[ $USER =~ \ |\' ]] || [[ $USER =~ [^a-z0-9\ ] ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NUsrTitle" --inputbox "$_NUsrErrBody" 0 0 "" 2>${ANSWER} || config_user_menu
              USER=$(cat ${ANSWER})
        done
        
        # Enter password. This step will only be reached where the loop has been skipped or broken.
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
        PASSWD=$(cat ${ANSWER}) 
    
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody2 $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
        PASSWD2=$(cat ${ANSWER}) 
    
        # loop while passwords entered do not match.
        while [[ $PASSWD != $PASSWD2 ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrErrTitle" --msgbox "$_PassNUsrErrBody" 0 0
              
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
              PASSWD=$(cat ${ANSWER}) 
    
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody2 $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
              PASSWD2=$(cat ${ANSWER}) 
        done      
    
        # create new user. This step will only be reached where the password loop has been skipped or broken.  
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NUsrSetTitle" --infobox "$_NUsrSetBody" 0 0
        sleep 2
        # Create the user, set password, then remove temporary password file
        arch_chroot "useradd ${USER} -m -g users -G wheel,storage,power,network,video,audio,lp -s /bin/bash" 2>/tmp/.errlog
        check_for_error
        echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
        arch_chroot "passwd ${USER}" < /tmp/.passwd >/dev/null 2>/tmp/.errlog
        rm /tmp/.passwd
        check_for_error
        # Set up basic configuration files and permissions for user
        arch_chroot "cp /etc/skel/.bashrc /home/${USER}"
        arch_chroot "chown -R ${USER}:users /home/${USER}"
        sed -i '/%wheel ALL=(ALL) ALL/s/^#//' ${MOUNTPOINT}/etc/sudoers
      
}

run_mkinitcpio() {
	
	clear

	# If $LVM is being used, add the lvm2 hook
	[[ $LVM -eq 1 ]] && sed -i 's/block filesystems/block lvm2 filesystems/g' ${MOUNTPOINT}/etc/mkinitcpio.conf
    
	# Amend command depending on whether LTS kernel was installed or not
	([[ $KERNEL -eq 1 ]] || [[ $KERNEL -eq 3 ]]) && arch_chroot "mkinitcpio -p linux" 2>/tmp/.errlog
	([[ $KERNEL -eq 2 ]] || [[ $KERNEL -eq 3 ]]) && arch_chroot "mkinitcpio -p linux-lts" 2>/tmp/.errlog
	check_for_error
 
}

######################################################################
##																	##
##            System and Partitioning Functions						##
##																	##
######################################################################



# Unmount partitions.
umount_partitions(){
	
  MOUNTED=""
  MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
  swapoff -a
  
  for i in ${MOUNTED[@]}; do
      umount $i >/dev/null 2>>/tmp/.errlog
  done
  
  check_for_error

}

# Revised to deal with partion sizes now being displayed to the user
confirm_mount() {
    if [[ $(mount | grep $1) ]]; then   
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusSucc" 0 0
      sleep 2
      PARTITIONS=$(echo $PARTITIONS | sed "s~${PARTITION} [0-9]*[G-M]~~" | sed "s~${PARTITION} [0-9]*\.[0-9]*[G-M]~~" | sed s~${PARTITION}$' -'~~)
      NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
    else
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusFail" 0 0
      sleep 2
      prep_menu
    fi
}

# btrfs specific for subvolumes
confirm_mount_btrfs() {
    if [[ $(mount | grep $1) ]]; then
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusSucc\n$(cat ${BTRFS_OPTS})",subvol="${BTRFS_MSUB_VOL}\n\n" 0 0
      sleep 2
    else
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusFail" 0 0
      sleep 2
      prep_menu
    fi
}

# Revised to include device size in menu display. This function does not assume that the formatted device 
# is the Root installation device as more than one device may be formatted. Root is set in the 
# mount_partitions function, when the Root is chosen.
select_device() {
	
    DEVICE=""
    devices_list=$(lsblk -lno NAME,SIZE,TYPE | grep 'disk' | awk '{print "/dev/" $1 " " $2}' | sort -u);
    
    for i in ${devices_list[@]}; do
        DEVICE="${DEVICE} ${i}"
    done
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevSelTitle" --menu "$_DevSelBody" 0 0 4 ${DEVICE} 2>${ANSWER} || prep_menu
    DEVICE=$(cat ${ANSWER})
 
  }

# Securely destroy all data on a given device.
secure_wipe(){
	
	# Warn the user. If they proceed, wipe the selected device.
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " $_PartOptWipe " --yesno "\nWARNING: ALL data on ${DEVICE} $_AutoPartWipeBody" 0 0
	if [[ $? -eq 0 ]]; then
	
		clear
		# Install wipe where not already installed. Much faster than dd
		if [[ $(pacman -Qs wipe) == "" ]]; then
			pacman -Sy --noconfirm wipe 2>/tmp/.errlog
			check_for_error
			clear
		fi
		
		echo -e "\n\nSecurly Wiping Device ${DEVICE}. Please be patient...\n\n"
		wipe -Ifre ${DEVICE}
		
		# Alternate dd command - requires pv to be installed
		#dd if=/dev/zero | pv | dd of=${DEVICE} iflag=nocache oflag=direct bs=4096 2>/tmp/.errlog
		check_for_error
    else
		create_partitions
    fi
}

# Originally adapted from AIS.
create_partitions(){

# This only creates the minimum number of partition(s) necessary. Users wishing for other schemes will
# have to learn to use a partitioning application.
auto_partition(){

# Hooray for tac! Deleting partitions in reverse order deals with logical partitions easily.
delete_partitions(){
	
	parted -s ${DEVICE} print | awk '/^ / {print $1}' > /tmp/.del_parts
	
	for del_part in $(tac /tmp/.del_parts); do
		parted -s ${DEVICE} rm ${del_part} 2>/tmp/.errlog
		check_for_error
	done


}
 
 # Identify the partition table
 part_table=$(parted -s ${DEVICE} print | grep -i 'partition table' | awk '{print $3}')

 # Autopartition for BIOS systems 
 if [[ $SYSTEM == "BIOS" ]]; then
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Auto-Partition (BIOS/MBR) " --yesno "$_AutoPartBody1 $DEVICE $_AutoPartBIOSBody2" 0 0
	
	if [[ $? -eq 0 ]]; then
	    delete_partitions
	    if [[ $part_table != "msdos" ]]; then
		   parted -s ${DEVICE} mklabel msdos 2>/tmp/.errlog
		   check_for_error
		fi
		parted -s ${DEVICE} mkpart primary ext3 1MiB 100% 2>/tmp/.errlog	
		parted -s ${DEVICE} set 1 boot on 2>>/tmp/.errlog
		check_for_error
        echo -e "Partition Scheme:\n" > /tmp/.devlist
        lsblk ${DEVICE} -o NAME,TYPE,FSTYPE,SIZE > /tmp/.devlist
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "" --textbox /tmp/.devlist 0 0
    else
        create_partitions
    fi
 
 # Autopartition for UEFI systems   
 else
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Auto-Partition (UEFI/GPT) " --yesno "$_AutoPartBody1 $DEVICE $_AutoPartUEFIBody2" 0 0
	
	if [[ $? -eq 0 ]]; then
	    delete_partitions
	    if [[ $part_table != "gpt" ]]; then
		   parted -s ${DEVICE} mklabel gpt 2>/tmp/.errlog
		   check_for_error
		fi
		parted -s ${DEVICE} mkpart ESP fat32 1MiB 513MiB 2>/tmp/.errlog
		parted -s ${DEVICE} set 1 boot on 2>>/tmp/.errlog
		parted -s ${DEVICE} mkpart primary ext3 513MiB 100% 2>>/tmp/.errlog
		echo -e "Partition Scheme:\n" > /tmp/.devlist
        lsblk ${DEVICE} -o NAME,TYPE,FSTYPE,SIZE >> /tmp/.devlist
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "" --textbox /tmp/.devlist 0 0
    else
		create_partitions
    fi
    
 fi

}

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PartToolTitle" \
    --menu "$_PartToolBody" 0 0 8 \
    "1" "$_PartOptWipe" \
    "2" "$_PartOptAutoStandard" \
    "3" "$_PartOptAutoLuks" \
 	"4" $"Parted (BIOS & UEFI)" \
	"5" $"CFDisk (BIOS/MBR)" \
	"6" $"CGDisk (UEFI/GPT)" \
	"7" $"FDisk  (BIOS & UEFI)" \
	"8" $"GDisk  (UEFI/GPT)" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") secure_wipe
             ;; 
        "2") auto_partition
             ;;   
        "3") luks_auto_partition
             ;;
        "4") clear
             parted ${DEVICE}
             ;;
        "5") cfdisk ${DEVICE}
             ;;
        "6") cgdisk ${DEVICE}
             ;;       
        "7") clear
             fdisk ${DEVICE}
             ;;
        "8") clear
             gdisk ${DEVICE}
             ;;
          *) prep_menu
             ;;
    esac  	
}	

# Revised to include partition sizes. Finds all available partitions and generate a list 
# of them. This also includes partitions on different devices.
find_partitions() {

	PARTITIONS=""
	NUMBER_PARTITIONS=0
	partition_list=$(lsblk -lno NAME,SIZE,TYPE | grep 'part\|lvm' | sed 's/part/\/dev\//g' | sed 's/lvm\|crypt/\/dev\/mapper\//g' |awk '{print $3$1 " " $2}' | sort -u)

    for i in ${partition_list[@]}; do
        PARTITIONS="${PARTITIONS} ${i}"
        NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
    done
    
    # Deal with incorrect partitioning
    if [[ $NUMBER_PARTITIONS -lt 2 ]] && [[ $SYSTEM == "UEFI" ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_UefiPartErrTitle" --msgbox "$_UefiPartErrBody" 0 0
        create_partitions
    fi
    
    if [[ $NUMBER_PARTITIONS -eq 0 ]] && [[ $SYSTEM == "BIOS" ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_BiosPartErrTitle" --msgbox "$_BiosPartErrBody" 0 0	
        create_partitions
    fi
}

# Set static list of filesystems rather than on-the-fly. Partially as most require additional flags, and 
# partially because some don't seem to be viable.
select_filesystem(){

	# Clear special FS type flags
	BTRFS=0
	F2FS=0

	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_FSTitle" --menu "$_FSBody" 0 0 12 \
	"$_FSSkip" "-" \
	"mkfs.btrfs -f" "btrfs" \
	"mkfs.ext2 -q" "ext2" \
	"mkfs.ext3 -q" "ext3" \
	"mkfs.ext4 -q" "ext4" \
	"mkfs.f2fs" "f2fs" \
	"mkfs.jfs -q" "jfs" \
	"mkfs.nilfs2 -q" "nilfs2" \
	"mkfs.ntfs -q" "ntfs" \
	"mkfs.reiserfs -q" "reiserfs" \
	"mkfs.vfat -F32" "vfat" \
	"mkfs.xfs -f" "xfs" 2>${ANSWER}	

	FILESYSTEM=$(cat ${ANSWER})

	[[ $FILESYSTEM == "mkfs.f2fs" ]] && modprobe f2fs && F2FS=1
	
	# If brtfs selected, ask if subvolumes are needed
	if [[ $FILESYSTEM == "mkfs.btrfs -f" ]]; then
		modprobe btrfs	
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVTitle" --yesno "$_btrfsSVBody" 0 0
		[[ $? -eq 0 ]] && BTRFS=2 || BTRFS=1
	fi

  }
  
mount_partitions() {

# subfunction for btrfs
btrfs_subvols() {

 BTRFS_MSUB_VOL=""
 BTRFS_OSUB_VOL=""
 BTRFS_MNT=""
 BTRFS_VOL_LIST="/tmp/.vols"
 echo "" > ${BTRFS_VOL_LIST}
 BTRFS_OSUB_NUM=1
 
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVTitle" --inputbox "$_btrfsMSubBody1 ${MOUNTPOINT}${MOUNT} $_btrfsMSubBody2" 0 0 "" 2>${ANSWER} || select_filesystem
 BTRFS_MSUB_VOL=$(cat ${ANSWER})
 # if root, then create boot flag for syslinux, systemd-boot and rEFInd bootloaders	
 [[ ${MOUNT} == "" ]] && BTRFS_MNT="rootflags=subvol="$BTRFS_MSUB_VOL

 # Loop while subvolume is blank or has spaces.
 while [[ ${#BTRFS_MSUB_VOL} -eq 0 ]] || [[ $BTRFS_MSUB_VOL =~ \ |\' ]]; do
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVErrTitle" --inputbox "$_btrfsSVErrBody" 0 0 "" 2>${ANSWER} || select_filesystem
       BTRFS_MSUB_VOL=$(cat ${ANSWER})
       # if root, then create flag for syslinux, systemd-boot and rEFInd bootloaders
       [[ ${MOUNT} == "" ]] && BTRFS_MNT="rootflags=subvol="$BTRFS_MSUB_VOL
 done
 
 # change dir depending on whether root partition or not
 [[ ${MOUNT} == "" ]] && cd ${MOUNTPOINT} || cd ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
 btrfs subvolume create ${BTRFS_MSUB_VOL} 2>>/tmp/.errlog
 cd
 umount ${PARTITION} 2>>/tmp/.errlog
 check_for_error
 
 # Get any mount options and mount
 btrfs_mount_opts
 if [[ $(cat ${BTRFS_OPTS}) != "" ]]; then
	[[ ${MOUNT} == "" ]] && mount -o $(cat ${BTRFS_OPTS})",subvol="${BTRFS_MSUB_VOL} ${PARTITION} ${MOUNTPOINT} 2>/tmp/.errlog || mount -o $(cat ${BTRFS_OPTS})",subvol="${BTRFS_MSUB_VOL} ${PARTITION} ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
 else
    [[ ${MOUNT} == "" ]] &&	mount -o "subvol="${BTRFS_MSUB_VOL} ${PARTITION} ${MOUNTPOINT} 2>/tmp/.errlog || mount -o "subvol="${BTRFS_MSUB_VOL} ${PARTITION} ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
 fi
 
 # Check for error and confirm successful mount
 check_for_error  
 [[ ${MOUNT} == "" ]] && confirm_mount_btrfs ${MOUNTPOINT} || confirm_mount_btrfs ${MOUNTPOINT}${MOUNT}
 
 # Now create the subvolumes   
 [[ ${MOUNT} == "" ]] && cd ${MOUNTPOINT} || cd ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
 check_for_error
 
 # Loop while the termination character has not been entered
 while [[ $BTRFS_OSUB_VOL != "*" ]]; do
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVTitle ($BTRFS_MSUB_VOL) " --inputbox "$_btrfsSVBody1 $BTRFS_OSUB_NUM $_btrfsSVBody2 $BTRFS_MSUB_VOL.$_btrfsSVBody3 $(cat ${BTRFS_VOL_LIST})" 0 0 "" 2>${ANSWER} || select_filesystem
	BTRFS_OSUB_VOL=$(cat ${ANSWER})	

    # Loop while subvolume is blank or has spaces.
    while [[ ${#BTRFS_OSUB_VOL} -eq 0 ]] || [[ $BTRFS_SUB_VOL =~ \ |\' ]]; do
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVErrTitle ($BTRFS_MSUB_VOL) " --inputbox "$_btrfsSVErrBody ($BTRFS_OSUB_NUM)." 0 0 "" 2>${ANSWER} || select_filesystem
       BTRFS_OSUB_VOL=$(cat ${ANSWER})
    done
 
    btrfs subvolume create ${BTRFS_OSUB_VOL} 2>/tmp/.errlog 
    check_for_error
    BTRFS_OSUB_NUM=$(( BTRFS_OSUB_NUM + 1 ))
    echo $BTRFS_OSUB_VOL" " >> ${BTRFS_VOL_LIST}
 done
 
 # Show the subvolumes created
 echo -e "btrfs subvols:\n" > /tmp/.subvols
 ls  >> /tmp/.subvols
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --textbox /tmp/.subvols 0 0
 cd
}

# This function allows for btrfs-specific mounting options to be applied. Written as a seperate function
# for neatness.
btrfs_mount_opts() {

	echo "" > ${BTRFS_OPTS}

	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsMntTitle" --checklist "$_btrfsMntBody" 0 0 16 \
	"autodefrag," "-" off \
	"compress=zlib," "-" off \
	"compress=lzo," "-" off \
	"compress=no," "-" off \
	"compress-force=zlib," "-" off \
	"compress-force=lzo," "-" off \
	"discard," "-" off \
	"noacl," "-" off \
    "noatime," "-" off \
	"nodatasum," "-" off \
	"nospace_cache," "-" off \
	"recovery," "-" off \
	"skip_balance," "-" off \
	"space_cache," "-" off \
	"ssd," "-" off \
	"ssd_spread," "-" off 2>${BTRFS_OPTS}
	
	# Now clean up the file
	sed -i 's/ //g' ${BTRFS_OPTS}
	sed -i '$s/,$//' ${BTRFS_OPTS}

   
   if [[ $(cat ${BTRFS_OPTS}) != "" ]]; then
	  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsMntTitle" --yesno "$_btrfsMntConfBody $(cat $BTRFS_OPTS)\n" 0 0 
	  [[ $? -eq 1 ]] && btrfs_mount_opts
   fi  

}

    # LVM Detection. If detected, activate.
    detect_lvm
    if [[ $LVM -eq 1 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmDetTitle" --infobox "$_LvmDetBody2" 0 0
       sleep 2   
       modprobe dm-mod 2>/tmp/.errlog
       check_for_error
       vgscan >/dev/null 2>&1
       vgchange -ay >/dev/null 2>&1
    fi

	# Ensure partitions are unmounted (i.e. where mounted previously), and then list available partitions
    umount_partitions
	find_partitions
	
	# Identify and mount root
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SelRootTitle" --menu "$_SelRootBody" 0 0 4 ${PARTITIONS} 2>${ANSWER} || prep_menu
	PARTITION=$(cat ${ANSWER})
    ROOT_PART=${PARTITION}

    # Identify if root is LVM
    [[ $(echo $ROOT_PART | grep "/dev/mapper/") == "" ]] && LVM_ROOT=0 || LVM_ROOT=1
    	
	select_filesystem
	[[ $FILESYSTEM != $_FSSkip ]] && ${FILESYSTEM} ${PARTITION} >/dev/null 2>/tmp/.errlog
	check_for_error
	
	# Make the root directory
	mkdir -p ${MOUNTPOINT} 2>/tmp/.errlog

    # If btrfs without subvolumes has been selected, get the mount options
    [[ $BTRFS -eq 1 ]] && btrfs_mount_opts
    
    # If btrfs has been selected without subvolumes - and at least one btrfs mount option selected - then
	# mount with options. Otherwise, basic mount.
	if [[ $BTRFS -eq 1 ]] && [[ $(cat ${BTRFS_OPTS}) != "" ]]; then
	   mount -o $(cat ${BTRFS_OPTS}) ${PARTITION} ${MOUNTPOINT} 2>>/tmp/.errlog
	else
	   mount ${PARTITION} ${MOUNTPOINT} 2>>/tmp/.errlog
    fi
	  
	# Check for error, confirm mount, and deal with BTRFS with subvolumes if applicable  
	check_for_error
    confirm_mount ${MOUNTPOINT}
    [[ $BTRFS -eq 2 ]] && btrfs_subvols
	
	# Identify and create swap, if applicable
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SelSwpTitle" --menu "$_SelSwpBody" 0 0 4 "$_SelSwpNone" $"-" "$_SelSwpFile" $"-" ${PARTITIONS} 2>${ANSWER} || prep_menu  
    if [[ $(cat ${ANSWER}) != "$_SelSwpNone" ]]; then    
       PARTITION=$(cat ${ANSWER})
       
       if [[ $PARTITION == "$_SelSwpFile" ]]; then
          total_memory=`grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//'`
          fallocate -l ${total_memory}M ${MOUNTPOINT}/swapfile >/dev/null 2>/tmp/.errlog
          check_for_error
          chmod 600 ${MOUNTPOINT}/swapfile >/dev/null 2>&1
          mkswap ${MOUNTPOINT}/swapfile >/dev/null 2>&1
          swapon ${MOUNTPOINT}/swapfile >/dev/null 2>&1
       else
          # Only create a swap if not already in place
          [[ $(lsblk -o FSTYPE  ${MOUNT_TYPE}${PARTITION} | grep -i "swap") != "swap" ]] &&  mkswap ${PARTITION} >/dev/null 2>/tmp/.errlog
          swapon  ${PARTITION} >/dev/null 2>>/tmp/.errlog
          check_for_error
          # Since a partition was used, remove that partition from the list
          PARTITIONS=$(echo $PARTITIONS | sed "s~${PARTITION} [0-9]*[G-M]~~" | sed "s~${PARTITION} [0-9]*\.[0-9]*[G-M]~~" | sed s~${PARTITION}$' -'~~)
		  NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
       fi
    fi
    
    # Extra Step for VFAT UEFI Partition. This cannot be in an LVM container.
    if [[ $SYSTEM == "UEFI" ]]; then
    
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SelUefiTitle" --menu "$_SelUefiBody" 0 0 4 ${PARTITIONS} 2>${ANSWER} || config_base_menu  
       PARTITION=$(cat ${ANSWER})
       UEFI_PART=${PARTITION}
       
       # If it is already a fat/vfat partition...
       if [[ $(fsck -N /dev/$PARTITION | grep fat) ]]; then
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_FormUefiTitle" --yesno "$_FormUefiBody $PARTITION $_FormUefiBody2" 0 0 && mkfs.vfat -F32 ${PARTITION} >/dev/null 2>/tmp/.errlog
       else 
          mkfs.vfat -F32 ${PARTITION} >/dev/null 2>/tmp/.errlog
       fi
       check_for_error
       
       # Inform users of the mountpoint options and consequences       
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntUefiTitle" --menu "$_MntUefiBody"  0 0 2 \
 	   "1" $"/boot" \
	   "2" $"/boot/efi" 2>${ANSWER}
       
       case $(cat ${ANSWER}) in
        "1") UEFI_MOUNT="/boot"
             ;;
        "2") UEFI_MOUNT="/boot/efi"
             ;;
          *) config_base_menu
             ;;
       esac
       
       mkdir -p ${MOUNTPOINT}${UEFI_MOUNT} 2>/tmp/.errlog
       mount ${PARTITION} ${MOUNTPOINT}${UEFI_MOUNT} 2>>/tmp/.errlog
       check_for_error
       confirm_mount ${MOUNTPOINT}${UEFI_MOUNT}     
       
    fi
    
    # All other partitions
       while [[ $NUMBER_PARTITIONS > 0 ]]; do 
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtPartTitle" --menu "$_ExtPartBody" 0 0 4 "$_Done" $"-" ${PARTITIONS} 2>${ANSWER} || config_base_menu 
             PARTITION=$(cat ${ANSWER})
             
             if [[ $PARTITION == ${_Done} ]]; then
                break;
             else
                MOUNT=""
                
                select_filesystem 
                [[ $FILESYSTEM != $_FSSkip ]] && ${FILESYSTEM} ${PARTITION} >/dev/null 2>/tmp/.errlog
	            check_for_error
	            
                # Don't give /boot as an example for UEFI systems!
                if [[ $SYSTEM == "UEFI" ]]; then
                   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyUefi" 0 0 "/" 2>${ANSWER} || config_base_menu
                else
                   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyBios" 0 0 "/" 2>${ANSWER} || config_base_menu
                fi
                MOUNT=$(cat ${ANSWER})
                
                # loop if the mountpoint specified is incorrect (is only '/', is blank, or has spaces). 
                while [[ ${MOUNT:0:1} != "/" ]] || [[ ${#MOUNT} -le 1 ]] || [[ $MOUNT =~ \ |\' ]]; do
                      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtErrTitle" --msgbox "$_ExtErrBody" 0 0
                      
                      # Don't give /boot as an example for UEFI systems!
                      if [[ $SYSTEM == "UEFI" ]]; then
                         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyUefi" 0 0 "/" 2>${ANSWER} || config_base_menu
                      else
                         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyBios" 0 0 "/" 2>${ANSWER} || config_base_menu
                      fi
                      MOUNT=$(cat ${ANSWER})                     
                done

                # Create directory and mount. This step will only be reached where the loop has been skipped or broken.
                mkdir -p ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
                
                # If btrfs without subvolumes has been selected, get the mount options
                [[ $BTRFS -eq 1 ]] && btrfs_mount_opts
    
                # If btrfs has been selected without subvolumes - and at least one btrfs mount option selected - then
	            # mount with options. Otherwise, basic mount.
	            if [[ $BTRFS -eq 1 ]] && [[ $(cat ${BTRFS_OPTS}) != "" ]]; then
					mount -o $(cat ${BTRFS_OPTS}) ${PARTITION} ${MOUNTPOINT}${MOUNT} 2>>/tmp/.errlog
				else
					mount ${PARTITION} ${MOUNTPOINT}${MOUNT} 2>>/tmp/.errlog
				fi
	  
				# Check for error, confirm mount, and deal with BTRFS with subvolumes if applicable  
				check_for_error
				confirm_mount ${MOUNTPOINT}${MOUNT}
				[[ $BTRFS -eq 2 ]] && btrfs_subvols
                
                # Determine if a seperate /boot is used, and if it is LVM or not
                LVM_SEP_BOOT=0
                [[ $MOUNT == "/boot" ]] && LVM_SEP_BOOT=1 || LVM_SEP_BOOT=2
                
             fi
       done
}	

######################################################################
##																	##
##             Logical Volume Management Functions			    	##
##																	##
######################################################################


# LVM Detection.
detect_lvm() {

  LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
  LVM_VG=$(vgs -o vg_name --noheading 2>/dev/null)
  LVM_LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)
  
  if [[ $LVM_LV = "" ]] && [[ $LVM_VG = "" ]] && [[ $LVM_PV = "" ]]; then
     LVM=0
  else
     LVM=1
  fi
 
}

# Where existing LVM is found, offer to deactivate it. Code adapted from the Manjaro installer.
# NEED TO ADD COMMAND TO REMOVE LVM2 FSTYPE.
deactivate_lvm() {

 LVM_DISABLE=0

    if [[ $LVM -eq 1 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmDetTitle" --yesno "$_LvmDetBody1" 0 0 \
       && LVM_DISABLE=1 || LVM_DISABLE=0
    fi
    
    if [[ $LVM_DISABLE -eq 1 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmRmTitle" --infobox "$_LvmRmBody" 0 0
       sleep 2
       
        for i in ${LVM_LV}; do
            lvremove -f /dev/mapper/${i} >/dev/null 2>&1
        done

        for i in ${LVM_VG}; do
            vgremove -f ${i} >/dev/null 2>&1
        done

        for i in ${LV_PV}; do
            pvremove -f ${i} >/dev/null 2>&1
        done
        
        # This step will remove old lvm metadata on partitions where identified.
        LVM_PT=$(lvmdiskscan | grep 'LVM physical volume' | grep 'sd\|hd\|vd\|nvme\|mmc' | sed 's/\/dev\///' | awk '{print $1}')
        for i in ${LVM_PT}; do
            dd if=/dev/zero bs=512 count=512 of=/dev/${i} >/dev/null 2>&1
        done
    fi

}

# Find and create a list of partitions that can be used for LVM. Partitions already used are excluded.
find_lvm_partitions() {

    LVM_PARTITIONS=""
    NUMBER_LVM_PARTITIONS=0
    lvm_partition_list=$(lsblk -lno NAME,SIZE,TYPE | grep 'lvm' | awk '{print $1 " " $2}' | sort -u)
	
    for i in ${lvm_partition_list[@]}; do
        LVM_PARTITIONS="${LVM_PARTITIONS} ${i}"
        NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS + 1 ))
    done
    
}

# This simplifies the creation of the PV and VG into a single step.
create_lvm() {

# subroutine to save a lot of repetition.
check_lv_size() {

  LV_SIZE_INVALID=0
  LV_SIZE_TYPE=$(echo ${LVM_LV_SIZE:$(( ${#LVM_LV_SIZE} - 1 )):1})
  chars=0
  
  # Check to see if anything was actually entered
  [[ ${#LVM_LV_SIZE} -eq 0 ]] && LV_SIZE_INVALID=1

  # Check if there are any non-numeric characters prior to the last one
  while [[ $chars -lt $(( ${#LVM_LV_SIZE} - 1 )) ]]; do
        if [[ ${LVM_LV_SIZE:chars:1} != [0-9] ]]; then
           LV_SIZE_INVALID=1
           break;
        fi
        chars=$(( chars + 1 ))
  done

  # Check to see if first character is '0'
  [[ ${LVM_LV_SIZE:0:1} -eq "0" ]] && LV_SIZE_INVALID=1

  # Check to see if last character is "G" or "M", and if so, whether the value is greater than
  # or equal to the LV remaining Size. If not, convert into MB for VG space remaining.      
  if [[ ${LV_SIZE_INVALID} -eq 0 ]]; then
      case ${LV_SIZE_TYPE} in
         "G") if [[ $(( $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) * 1000 )) -ge ${LVM_VG_MB} ]]; then
                 LV_SIZE_INVALID=1
              else
                 LVM_VG_MB=$(( LVM_VG_MB - $(( $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) * 1000 )) ))
              fi
              ;;
         "M") if [[ $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) -ge ${LVM_VG_MB} ]]; then
                 LV_SIZE_INVALID=1
              else
                 LVM_VG_MB=$(( LVM_VG_MB - $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) ))
              fi
              ;;
           *) LV_SIZE_INVALID=1
              ;;
      esac
  fi
      
}

	# Check that there is at least one partition available for LVM
    if [[ $NUMBER_LVM_PARTITIONS -lt 1 ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPartErrTitle" --msgbox "$_LvmPartErrBody" 0 0
        prep_menu
    fi
    
    # Create a temporary file to store the partition(s) selected. This is later used for the vgcreate command. 'x' is used as a marker.
    echo "x" > /tmp/.vgcreate
    
    # Name the Volume Group
    LVM_VG=""
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmNameVgTitle" --inputbox "$_LvmNameVgBody" 0 0 "" 2>${ANSWER} || prep_menu
    LVM_VG=$(cat ${ANSWER})

    # Loop while the Volume Group name starts with a "/", is blank, has spaces, or is already being used
    while [[ ${LVM_VG:0:1} == "/" ]] || [[ ${#LVM_VG} -eq 0 ]] || [[ $LVM_VG =~ \ |\' ]] || [[ $(lsblk | grep ${LVM_VG}) != "" ]]; do
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmNameVgErrTitle" --msgbox "$_LvmNameVgErr" 0 0
              
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmNameVgTitle" --inputbox "$_LvmNameVgBody" 0 0 "" 2>${ANSWER} || prep_menu
        LVM_VG=$(cat ${ANSWER})
    done
    
    # Select the first or only partition for the Volume Group
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvSelTitle" --menu "$_LvmPvSelBody" 0 0 4 ${LVM_PARTITIONS} 2>${ANSWER} || prep_menu 
    LVM_PARTITION=$(cat ${ANSWER})
    
    # add the partition to the temporary file for the vgcreate command
    # Remove selected partition from the list and deduct number of LVM viable partitions remaining
    # FIX TO INCLUDE PARTITION SIZES
    sed -i "s/x/\/dev\/${LVM_PARTITION} x/" /tmp/.vgcreate
    LVM_PARTITIONS="$(echo $LVM_PARTITIONS | sed s/${LVM_PARTITION}$' -'//)"
    NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS - 1 ))
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvCreateTitle" --infobox "\n$_Done\n\n" 0 0
    sleep 1

    # Where there are viable partitions still remaining, run loop
    while [[ $NUMBER_LVM_PARTITIONS -gt 0 ]]; do

           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvSelTitle" --menu "$_LvmPvSelBody" 0 0 4 $"Done" $"-" ${LVM_PARTITIONS} 2>${ANSWER} || prep_menu 
           LVM_PARTITION=$(cat ${ANSWER})

           if [[ $LVM_PARTITION == "Done" ]]; then
              break;
           else
              sed -i "s/x/\/dev\/${LVM_PARTITION} x/" /tmp/.vgcreate
              LVM_PARTITIONS="$(echo $LVM_PARTITIONS | sed s/${LVM_PARTITION}$' -'//)"
              NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS - 1 ))
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvCreateTitle" --infobox "\n$_Done\n\n" 0 0
              sleep 1
           fi

    done

    # Once all the partitions have been selected, remove 'x' from the .vgcreate file, then use it in 'vgcreate' command.
    # Also determine the size of the VG, to use for creating LVs for it.
    VG_PARTS=$(cat /tmp/.vgcreate | sed 's/x//')
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvConfTitle" --yesno "$_LvmPvConfBody1${LVM_VG} $_LvmPvConfBody2${VG_PARTS}" 0 0
    
    if [[ $? -eq 0 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvActTitle" --infobox "$_LvmPvActBody1${LVM_VG}.$_LvmPvActBody2" 0 0
       sleep 2
       vgcreate -f ${LVM_VG} ${VG_PARTS} >/dev/null 2>/tmp/.errlog
       check_for_error
       VG_SIZE=$(vgdisplay | grep 'VG Size' | awk '{print $3}' | sed 's/\..*//')
       VG_SIZE_TYPE=$(vgdisplay | grep 'VG Size' | awk '{print $4}' | sed 's/\..*//')
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvDoneTitle" --msgbox "$_LvmPvDoneBody1 '${LVM_VG}' $_LvmPvDoneBody2 (${VG_SIZE} ${VG_SIZE_TYPE}).\n\n" 0 0
       sleep 2
    else
       prep_menu
    fi

    # Convert the VG size into GB and MB. These variables are used to keep tabs on space available and remaining
    [[ ${VG_SIZE_TYPE:0:1} == "G" ]] && LVM_VG_MB=$(( VG_SIZE * 1000 )) || LVM_VG_MB=$VG_SIZE
    
    # Specify number of Logical volumes to create.
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNumTitle" --inputbox "$_LvmLvNumBody1 ${LVM_VG}.$_LvmLvNumBody2" 0 0 "" 2>${ANSWER} || prep_menu
    NUMBER_LOGICAL_VOLUMES=$(cat ${ANSWER})
    
    # Loop if the number of LVs is no 1-9 (including non-valid characters)
    while [[ $NUMBER_LOGICAL_VOLUMES != [1-9] ]]; do
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNumErrTitle" --msgbox "$_LvmLvNumErrBody" 0 0
 
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNumTitle" --inputbox "$_LvmLvNumBody1 ${LVM_VG}.$_LvmLvNumBody2" 0 0 "" 2>${ANSWER} || prep_menu
          NUMBER_LOGICAL_VOLUMES=$(cat ${ANSWER})
    done

    # Loop while the number of LVs is greater than 1. This is because the size of the last LV is automatic.
    while [[ $NUMBER_LOGICAL_VOLUMES -gt 1 ]]; do
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1" 0 0 "lvol" 2>${ANSWER} || prep_menu
          LVM_LV_NAME=$(cat ${ANSWER})

          # Loop if preceeded with a "/", if nothing is entered, if there is a space, or if that name already exists.
          while [[ ${LVM_LV_NAME:0:1} == "/" ]] || [[ ${#LVM_LV_NAME} -eq 0 ]] || [[ ${LVM_LV_NAME} =~ \ |\' ]] || [[ $(lsblk | grep ${LVM_LV_NAME}) != "" ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameErrTitle" --msgbox "$_LvmLvNameErrBody" 0 0

              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1" 0 0 "lvol" 2>${ANSWER} || prep_menu
              LVM_LV_NAME=$(cat ${ANSWER})
          done

          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvSizeTitle" --inputbox "\n${LVM_VG}: ${VG_SIZE}${VG_SIZE_TYPE} (${LVM_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2" 0 0 "" 2>${ANSWER} || prep_menu
          LVM_LV_SIZE=$(cat ${ANSWER})          
          check_lv_size 
          
          # Loop while an invalid value is entered.
          while [[ $LV_SIZE_INVALID -eq 1 ]]; do
                dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvSizeErrTitle" --msgbox "$_LvmLvSizeErrBody" 0 0
          
                dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvSizeTitle" --inputbox "\n${LVM_VG}: ${VG_SIZE}${VG_SIZE_TYPE} (${LVM_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2" 0 0 "" 2>${ANSWER} || prep_menu
                LVM_LV_SIZE=$(cat ${ANSWER})          
                check_lv_size
          done
          
          # Create the LV
          lvcreate -L ${LVM_LV_SIZE} ${LVM_VG} -n ${LVM_LV_NAME} 2>/tmp/.errlog
          check_for_error
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvDoneTitle" --msgbox "\n$_Done\n\nLV ${LVM_LV_NAME} (${LVM_LV_SIZE}) $_LvmPvDoneBody2.\n\n" 0 0
          NUMBER_LOGICAL_VOLUMES=$(( NUMBER_LOGICAL_VOLUMES - 1 ))
    done
    
    # Now the final LV. Size is automatic.      
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1 $_LvmLvNameBody2 (${LVM_VG_MB}MB)." 0 0 "lvol" 2>${ANSWER} || prep_menu
    LVM_LV_NAME=$(cat ${ANSWER})

          # Loop if preceeded with a "/", if nothing is entered, if there is a space, or if that name already exists.
          while [[ ${LVM_LV_NAME:0:1} == "/" ]] || [[ ${#LVM_LV_NAME} -eq 0 ]] || [[ ${LVM_LV_NAME} =~ \ |\' ]] || [[ $(lsblk | grep ${LVM_LV_NAME}) != "" ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameErrTitle" --msgbox "$_LvmLvNameErrBody" 0 0

              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1 $_LvmLvNameBody2 (${LVM_VG_MB}MB)." 0 0 "lvol" 2>${ANSWER} || prep_menu
              LVM_LV_NAME=$(cat ${ANSWER})
          done

    # Create the final LV
    lvcreate -l +100%FREE ${LVM_VG} -n ${LVM_LV_NAME} 2>/tmp/.errlog
    check_for_error
    NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS - 1 ))
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmCompTitle" --yesno "$_LvmCompBody" 0 0 \
    && show_devices || prep_menu
}

######################################################################
##																	##
##                    Installation Functions						##
##																	##
######################################################################	

# The linux kernel package will be removed from the base group as it and/or the lts version will be
# selected by the user. Two installation methods are available: Standard (group package based) and
# Advanced (individual package based). Neither will allow progress without selecting a kernel.
install_base() {

	# Prep variables
	echo "" > ${PACKAGES}
	echo "" > ${ANSWER}
	BTRF_CHECK=""
	F2FS_CHECK=""
	BASE_LIST=""
	
	# Need a seperate base-devel package list as there are so many duplicates with the base group.
	base_list=$(echo $(pacman -Sqg base) | sed s/" linux "/" "/ | sort -u)
	BASE_DEV_LIST=$(echo "autoconf automake binutils bison fakeroot flex gcc groff libtool m4 make patch pkg-config sudo" \
				| sed s/" "/" base-devel on "/g | sed s/$/" base-devel on "/g)

	for i in ${base_list}; do
		BASE_LIST="${BASE_LIST} ${i} base on"
	done

	# If btrfs and/or f2fs was used, auto-select the necessary packages for installation 
	[[ $BTRFS -gt 0 ]] && BTRF_CHECK=$(echo "btrfs-progs" "-" on) || BTRF_CHECK=$(echo "btrfs-progs" "-" off)
	[[ $F2FS -gt 0 ]] && F2FS_CHECK=$(echo "f2fs-tools" "-" on) || F2FS_CHECK=$(echo "f2fs-tools" "-" off)

	# User to select "standard" or "advanced" installation Method
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBseTitle" --menu "$_InstBseBody" 0 0 2 \
 	"1" "$_InstStandBase" \
	"2" "$_InstAdvBase" 2>${ANSWER}

	# "Standard" installation method
	if [[ $(cat ${ANSWER}) -eq 1 ]]; then
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBseTitle" --checklist "$_InstStandBseBody$_UseSpaceBar" 0 0 6 \
		"linux" "-" on "linux-lts" "-" off "base-devel" "-" on $BTRF_CHECK $F2FS_CHECK "sudo" "-" on 2>${PACKAGES}
	elif [[ $(cat ${ANSWER}) -eq 2 ]]; then
	# "Advanced" installation method
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBseTitle" --checklist "$_InstAdvBseBody $_UseSpaceBar" 0 0 0 \
		"linux" "base" on "linux-lts" "core" off $BASE_LIST $BASE_DEV_LIST $BTRF_CHECK $F2FS_CHECK 2>${PACKAGES}
    fi
    
    # Determine kernel type(s) selected for installation.
    if 	[[ $(cat ${PACKAGES}) != "" ]]; then
		[[ $(cat ${PACKAGES} | grep -w "linux") != "" ]] && [[ $(cat ${PACKAGES} | grep "linux-lts") != "" ]] && KERNEL=3
		[[ $(cat ${PACKAGES} | grep -w "linux") == "" ]] && [[ $(cat ${PACKAGES} | grep "linux-lts") != "" ]] && KERNEL=2
		[[ $(cat ${PACKAGES} | grep -w "linux") != "" ]] && [[ $(cat ${PACKAGES} | grep "linux-lts") == "" ]] && KERNEL=1
		[[ $(cat ${PACKAGES} | grep -w "linux") == "" ]] && [[ $(cat ${PACKAGES} | grep "linux-lts") == "" ]] && KERNEL=0
	
		if [[ $KERNEL -gt 0 ]]; then
			clear
			[[ $(cat ${ANSWER}) -eq 1 ]] && pacstrap ${MOUNTPOINT} $(pacman -Sqg base | sed 's/linux//' | sed 's/util-/util-linux/') $(cat ${PACKAGES}) 2>/tmp/.errlog
			[[ $(cat ${ANSWER}) -eq 2 ]] && pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
			check_for_error
		
			# If the virtual console has been set, then copy config file to installation
			[[ -e /tmp/vconsole.conf ]] && cp /tmp/vconsole.conf ${MOUNTPOINT}/etc/vconsole.conf 2>/tmp/.errlog
			check_for_error
		else
			dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$_ErrNoKernel" 0 0
			install_base
		fi
	fi

}

install_bootloader() {

# Grub auto-detects installed kernels, etc. Syslinux does not, hence the extra code for it.
bios_bootloader() {	
	
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBiosBtTitle" --menu "$_InstBiosBtBody" 0 0 3 \
 	"grub" "-" "grub + os-prober" "-" "syslinux" "-" 2>${PACKAGES}
	clear
	
	# If something has been selected, act
	if [[ $(cat ${PACKAGES}) != "" ]]; then
		sed -i 's/+\|\"//g' ${PACKAGES}
		pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
		check_for_error
		
		# If Grub, select device
		if [[ $(cat ${PACKAGES} | grep "grub") != "" ]]; then
			select_device
			
			# If a device has been selected, configure
			if [[ $DEVICE != "" ]]; then
				clear
				arch_chroot "grub-install --target=i386-pc --debug --recheck $DEVICE" 2>/tmp/.errlog
				arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>>/tmp/.errlog
				check_for_error
				
				# if /boot is LVM then amend /boot/grub/grub.cfg accordingly
				if ( [[ $LVM_ROOT -eq 1 ]] && [[ $LVM_SEP_BOOT -eq 0 ]] ) || [[ $LVM_SEP_BOOT -eq 2 ]]; then
					sed -i '/### BEGIN \/etc\/grub.d\/00_header ###/a insmod lvm' ${MOUNTPOINT}/boot/grub/grub.cfg
				fi
			fi
		else
			# Syslinux
			dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstSysTitle" --menu "$_InstSysBody" 0 0 2 \
			"syslinux-install_update -iam" "[MBR]" "syslinux-install_update -i" "[/]" 2>${PACKAGES}
			
			# If an installation method has been chosen, run it
			if [[ $(cat ${PACKAGES}) != "" ]]; then
				arch_chroot "$(cat ${PACKAGES})" 2>/tmp/.errlog
				check_for_error

				# Amend configuration file to specify root.
				sed -i "s~APPEND.*~APPEND root=${ROOT_PART} rw~g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg

				# Amend configuration file for kernel(s) installed
				if [[ $KERNEL -eq 3 ]]; then
					sed -i "/INITRD \.\.\/initramfs-linux\.img/a--insert--\nLABEL arch-lts\n\tMENU LABEL Arch Linux LTS\n\tLINUX \.\.\/vmlinuz-linux-lts\n\tAPPEND root=$ROOT_PART rw\n\tINITRD \.\./initramfs-linux-lts\.img" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
					sed -i "/INITRD \.\.\/initramfs-linux-fallback\.img/a--insert--\nLABEL archfallback-lts\n\tMENU LABEL Arch Linux Fallback LTS\n\tLINUX \.\.\/vmlinuz-linux-lts\n\tAPPEND root=$ROOT_PART rw\n\tINITRD \.\./initramfs-linux-fallback-lts\.img" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
					sed -i s/--insert--//g ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
				elif [[ $KERNEL -eq 2 ]]; then
					sed -i 's/linux/linux-lts/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
				fi
				
				# If BTRFS Subvolume mount	
				[[ $BTRFS_MNT != "" ]] && sed -i "s/rw/rw $BTRFS_MNT/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
			fi
		fi
	fi
}

uefi_bootloader() {

    #Ensure again that efivarfs is mounted
	[[ -z $(mount | grep /sys/firmware/efi/efivars) ]] && mount -t efivarfs efivarfs /sys/firmware/efi/efivars
     
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstUefiBtTitle" --menu "$_InstUefiBtBody" 0 0 3 \
    "grub" "-" "refind-efi" "-" "[systemd-boot]" "-" 2>${PACKAGES}

     case $(cat ${ANSWER}) in
     "1") # Grub2
          clear
          pacstrap ${MOUNTPOINT} grub os-prober efibootmgr dosfstools 2>/tmp/.errlog
          check_for_error
          
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Grub-install " --infobox "$_PlsWaitBody" 0 0
          sleep 1
          arch_chroot "grub-install --target=x86_64-efi --efi-directory=${UEFI_MOUNT} --bootloader-id=arch_grub --recheck" 2>/tmp/.errlog
          arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>>/tmp/.errlog
          check_for_error

          # Ask if user wishes to set Grub as the default bootloader and act accordingly
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SetGrubDefTitle" --yesno "$_SetGrubDefBody ${UEFI_MOUNT}/EFI/boot $_SetGrubDefBody2" 0 0
          
          if [[ $? -eq 0 ]]; then
             arch_chroot "mkdir ${UEFI_MOUNT}/EFI/boot" 2>/tmp/.errlog
             arch_chroot "cp -r ${UEFI_MOUNT}/EFI/arch_grub/grubx64.efi ${UEFI_MOUNT}/EFI/boot/bootx64.efi" 2>>/tmp/.errlog
             check_for_error
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SetDefDoneTitle" --infobox "\nGrub $_SetDefDoneBody" 0 0
             sleep 2
          fi
          
          BOOTLOADER="Grub"
          ;;
 
      "2") # rEFInd
           # Ensure that UEFI partition has been mounted to /boot/efi due to bug in script. Could "fix" it for installation, but
           # This could result in unknown consequences should the script be updated at some point.
           if [[ $UEFI_MOUNT == "/boot/efi" ]]; then      
              clear
              pacstrap ${MOUNTPOINT} refind-efi efibootmgr dosfstools 2>/tmp/.errlog
              check_for_error   
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SetRefiDefTitle" --yesno "$_SetRefiDefBody ${UEFI_MOUNT}/EFI/boot $_SetRefiDefBody2" 0 0
              
              if [[ $? -eq 0 ]]; then
                 clear
                 arch_chroot "refind-install --usedefault ${UEFI_PART} --alldrivers" 2>/tmp/.errlog
              else   
                 clear
                 arch_chroot "refind-install" 2>/tmp/.errlog
              fi   
              
              check_for_error
              
              # Now generate config file to pass kernel parameters. Default read only (ro) changed to read-write (rw),
              # and amend where using btfs subvol root       
              arch_chroot "refind-mkrlconf" 2>/tmp/.errlog
              check_for_error
              sed -i 's/ro /rw /g' ${MOUNTPOINT}/boot/refind_linux.conf
              [[ $BTRFS_MNT != "" ]] && sed -i "s/rw/rw $BTRFS_MNT/g" ${MOUNTPOINT}/boot/refind_linux.conf
              
              BOOTLOADER="rEFInd"
           else 
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_RefiErrTitle" --msgbox "$_RefiErrBody" 0 0
              uefi_bootloader
           fi
           ;;
         
     "3") # systemd-boot
          clear
          pacstrap ${MOUNTPOINT} efibootmgr dosfstools 2>/tmp/.errlog
          arch_chroot "bootctl --path=${UEFI_MOUNT} install" 2>>/tmp/.errlog
          check_for_error
          
          # Deal with LVM Root
          if [[ $(echo $ROOT_PART | grep "/dev/mapper/") == "" ]]; then
			sysdb_root=$(blkid -s PARTUUID ${ROOT_PART} | sed 's/.*=//g' | sed 's/"//g')
          else
             sysdb_root=$ROOT_PART 
          fi
           
          # Deal with LTS Kernel
          if [[ $LTS -eq 1 ]]; then
            echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux-lts\ninitrd\t/initramfs-linux-lts.img\noptions\troot=PARTUUID=${sysdb_root} rw" > ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf
          else
            echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux\ninitrd\t/initramfs-linux.img\noptions\troot=PARTUUID=${sysdb_root} rw" > ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf
          fi
          
          # Fix LVM Root installations, and deal with btrfs root subvolume mounting
          [[ $LVM_ROOT -eq 1 ]] && sed -i "s/PARTUUID=//g" ${MOUNTPOINT}/boot/loader/entries/arch.conf
          [[ $BTRFS_MNT != "" ]] && sed -i "s/rw/rw $BTRFS_MNT/g" ${MOUNTPOINT}/boot/loader/entries/arch.conf
          
          BOOTLOADER="systemd-boot"
          # Set the loader file  
          echo -e "default  arch\ntimeout  5" > ${MOUNTPOINT}${UEFI_MOUNT}/loader/loader.conf 2>/tmp/.errlog
          check_for_error
          ;;
          
      *) install_base_menu
         ;;
      esac 

}

    check_mount
    # Set the default PATH variable
    arch_chroot "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog
    check_for_error

    if [[ $SYSTEM == "BIOS" ]]; then
       bios_bootloader
    else
       uefi_bootloader
    fi
}

# Needed for broadcom and other network controllers
install_wireless_packages() {
    
    check_mount

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelssOptTitle" --menu "$_WirelessOptBody" 0 0 2 \
 	"1" "$_SeeWirelessDev" \
 	"2" "$_WirelssOptTitle" 2>${ANSWER}

    case $(cat ${ANSWER}) in
    "1") # Identify the Wireless Device 
        lspci -k | grep -i -A 2 "network controller" > /tmp/.wireless
        if [[ $(cat /tmp/.wireless) != "" ]]; then
           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelessShowTitle" --textbox /tmp/.wireless 0 0
        else
           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelessShowTitle" --msgbox "$_WirelessErrBody" 7 30
        fi
        
        install_wireless_packages
        ;;
    "2") # Install Wireless Device Packages
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " $_WirelssOptTitle " --checklist "$_WirelssBody $_UseSpaceBar" 0 0 11 \
		"dialog" "wifi" on \
		"iw" "wifi" on \
		"rp-pppoe" "wifi" on \
		"wireless_tools" "wifi" on \
		"wpa_actiond" "wifi" on \
		"wpa_supplicant" "wifi" on \
		"b43-fwcutter" "Broadcom 802.11b/g/n" off \
		"bluez-firmware" "Broadcom BCM203x / STLC2300 Bluetooth" off \
		"ipw2100-fw" "Intel PRO/Wireless 2100" off \
		"ipw2200-fw" "Intel PRO/Wireless 2200" off \
		"zd1211-firmware" "ZyDAS ZD1211(b) 802.11a/b/g USB WLAN" off 2>${PACKAGES}

		# If at least one package, install.
		if [[ $(cat ${PACKAGES}) != "" ]]; then
			pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
			check_for_error
		fi
        ;;
      *) install_base_menu
        ;;
    esac
}

# Install alsa, xorg and input drivers. Also copy the xkbmap configuration file created earlier to the installed system
# This will run only once.
install_alsa_xorg_input() {

	echo "" > ${PACKAGES}

	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_AXITitle" --checklist "$_AXIBody$_UseSpaceBar" 0 0 10 \
	"alsa-utils" "-" on \
	"xorg-server" "-" on \
	"xorg-server-common" "-" off \
	"xorg-server-utils" "-" on \
	"xorg-xinit" "-" on \
	"xf86-input-evdev" "-" off \
	"xf86-input-joystick" "-" off \
	"xf86-input-keyboard" "-" on \
	"xf86-input-mouse" "-" on \
	"xf86-input-synaptics" "-" on 2>${PACKAGES}

	# If at least one package, install.
	if [[ $(cat ${PACKAGES}) != "" ]]; then
		pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
		check_for_error
	fi
     
	# copy the keyboard configuration file, if generated
	[[ -e /tmp/00-keyboard.conf ]] && cp /tmp/00-keyboard.conf ${MOUNTPOINT}/etc/X11/xorg.conf.d/00-keyboard.conf
  
	# now copy across .xinitrc for all user accounts
	user_list=$(ls ${MOUNTPOINT}/home/ | sed "s/lost+found//")
	for i in ${user_list[@]}; do
		cp -f ${MOUNTPOINT}/etc/X11/xinit/xinitrc ${MOUNTPOINT}/home/$i
		arch_chroot "chown -R ${i}:users /home/${i}"
	done
    
    # Ensure option is only shown once 
	AXI_INSTALLED=1

}

setup_graphics_card() {

# Save repetition
install_intel(){

	pacstrap ${MOUNTPOINT} xf86-video-intel libva-intel-driver intel-ucode 2>/tmp/.errlog
    sed -i 's/MODULES=""/MODULES="i915"/' ${MOUNTPOINT}/etc/mkinitcpio.conf
           
    # Intel microcode (Grub, Syslinux and systemd-boot). rEFInd is yet to be added.
    # Done as seperate if statements in case of multiple bootloaders.
    if [[ -e ${MOUNTPOINT}/boot/grub/grub.cfg ]]; then
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " grub-mkconfig " --infobox "$_PlsWaitBody" 0 0
		sleep 1
		arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>>/tmp/.errlog
	fi
			   
	if [[ -e ${MOUNTPOINT}/boot/syslinux/syslinux.cfg ]]; then
		sed -i 's/..\/initramfs-linux.img/..\/intel-ucode.img,..\/initramfs-linux.img/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
		sed -i 's/..\/initramfs-linux-lts.img/..\/intel-ucode.img,..\/initramfs-linux-lts.img/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
		sed -i 's/..\/initramfs-linux-fallback.img/..\/intel-ucode.img,..\/initramfs-linux-fallback.img/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
		sed -i 's/..\/initramfs-linux-lts-fallback.img/..\/intel-ucode.img,..\/initramfs-linux-lts-fallback.img/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
	fi
			   
	if [[ -e ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf ]]; then
		sed -i '/linux \//a initrd \/intel-ucode.img' ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf                    
	fi
}

# Save repetition
install_ati(){
	pacstrap ${MOUNTPOINT} xf86-video-ati 2>/tmp/.errlog
	sed -i 's/MODULES=""/MODULES="radeon"/' ${MOUNTPOINT}/etc/mkinitcpio.conf
}

# Main menu. Correct option for graphics card should be automatically highlighted.
	NVIDIA=""
	VB_MOD=""
	GRAPHIC_CARD=""
	INTEGRATED_GC="N/A"
	GRAPHIC_CARD=$(lspci | grep -i "vga" | sed 's/.*://' | sed 's/(.*//' | sed 's/^[ \t]*//')
	
	# Highlight menu entry depending on GC detected. Extra work is needed for NVIDIA
	if 	[[ $(echo $GRAPHIC_CARD | grep -i "nvidia") != "" ]]; then
		# If NVIDIA, first need to know the integrated GC
		[[ $(lscpu | grep -i "intel\|lenovo") != "" ]] && INTEGRATED_GC="Intel" || INTEGRATED_GC="ATI"
				
		# Second, identity the NVIDIA card and driver / menu entry
		if [[ $(dmesg | grep -i 'chipset' | grep -i 'nvc\|nvd\|nve') != "" ]]; then HIGHLIGHT_SUB_GC=4
		elif [[ $(dmesg | grep -i 'chipset' | grep -i 'nva\|nv5\|nv8\|nv9'﻿) != "" ]]; then HIGHLIGHT_SUB_GC=5
		elif [[ $(dmesg | grep -i 'chipset' | grep -i 'nv4\|nv6') != "" ]]; then HIGHLIGHT_SUB_GC=6
		else HIGHLIGHT_SUB_GC=3
		fi
	
	# All non-NVIDIA cards / virtualisation
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'intel\|lenovo') != "" ]]; then HIGHLIGHT_SUB_GC=2
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'ati') != "" ]]; then HIGHLIGHT_SUB_GC=1
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'via') != "" ]]; then HIGHLIGHT_SUB_GC=7
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'virtualbox') != "" ]]; then HIGHLIGHT_SUB_GC=8
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'vmware') != "" ]]; then HIGHLIGHT_SUB_GC=9
	else HIGHLIGHT_SUB_GC=10
	fi
	
   dialog --default-item ${HIGHLIGHT_SUB_GC} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_GCtitle" \
    --menu "$GRAPHIC_CARD\n" 0 0 10 \
 	"1" $"xf86-video-ati" \
	"2" $"xf86-video-intel" \
	"3" $"xf86-video-nouveau (+ $INTEGRATED_GC)" \
	"4" $"Nvidia (+ $INTEGRATED_GC)" \
	"5" $"Nvidia-340xx (+ $INTEGRATED_GC)" \
	"6" $"Nvidia-304xx (+ $INTEGRATED_GC)" \
	"7" $"xf86-video-openchrome" \
	"8" $"virtualbox-guest-xxx" \
    "9" $"xf86-video-vmware" \
	"10" "$_GCUnknOpt / xf86-video-fbdev" 2>${ANSWER}

   case $(cat ${ANSWER}) in
        "1") # ATI/AMD
			install_ati
             ;;
        "2") # Intel
			install_intel
             ;;
        "3") # Nouveau / NVIDIA
			[[ $INTEGRATED_GC == "ATI" ]] &&  install_ati || install_intel
			pacstrap ${MOUNTPOINT} xf86-video-nouveau 2>/tmp/.errlog
            sed -i 's/MODULES=""/MODULES="nouveau"/' ${MOUNTPOINT}/etc/mkinitcpio.conf       
             ;;
        "4") # NVIDIA-GF
			[[ $INTEGRATED_GC == "ATI" ]] &&  install_ati || install_intel
			arch_chroot "pacman -Rdds --noconfirm mesa-libgl mesa"
 
 			# Set NVIDIA driver(s) to install depending on installed kernel(s)
			[[ $KERNEL == 3 ]] && NVIDIA="nvidia nvidia-lts"
			[[ $KERNEL == 2 ]] && NVIDIA="nvidia-lts"
			[[ $KERNEL == 1 ]] && NVIDIA="nvidia"

			clear
			pacstrap ${MOUNTPOINT} ${NVIDIA} nvidia-libgl nvidia-utils pangox-compat 2>/tmp/.errlog
            NVIDIA_INST=1
             ;;
        "5") # NVIDIA-340

			[[ $INTEGRATED_GC == "ATI" ]] &&  install_ati || install_intel
			arch_chroot "pacman -Rdds --noconfirm mesa-libgl mesa"

			# Set NVIDIA driver(s) to install depending on installed kernel(s)
			[[ $KERNEL == 3 ]] && NVIDIA="nvidia-340xx nvidia-340xx-lts"
			[[ $KERNEL == 2 ]] && NVIDIA="nvidia-340xx-lts"
			[[ $KERNEL == 1 ]] && NVIDIA="nvidia-340xx"

			clear
            pacstrap ${MOUNTPOINT} ${NVIDIA} nvidia-340xx-libgl nvidia-340xx-utils 2>/tmp/.errlog 
            NVIDIA_INST=1
             ;;
        "6") # NVIDIA-304
			[[ $INTEGRATED_GC == "ATI" ]] &&  install_ati || install_intel
			arch_chroot "pacman -Rdds --noconfirm mesa-libgl mesa"
			
  			# Set NVIDIA driver(s) to install depending on installed kernel(s)
			[[ $KERNEL == 3 ]] && NVIDIA="nvidia-304xx nvidia-304xx-lts"
			[[ $KERNEL == 2 ]] && NVIDIA="nvidia-304xx-lts"
			[[ $KERNEL == 1 ]] && NVIDIA="nvidia-304xx"

			clear
            pacstrap ${MOUNTPOINT} ${NVIDIA} nvidia-304xx-libgl nvidia-304xx-utils 2>/tmp/.errlog
            NVIDIA_INST=1
             ;;              
        "7") # Via
			pacstrap ${MOUNTPOINT} xf86-video-openchrome 2>/tmp/.errlog
             ;;            
        "8") # VirtualBox
        
			# Set VB modules to install depending on installed kernel(s)
			[[ $KERNEL == 3 ]] && VB_MOD="virtualbox-guest-modules virtualbox-guest-modules-lts"
			[[ $KERNEL == 2 ]] && VB_MOD="virtualbox-guest-modules-lts"
			[[ $KERNEL == 1 ]] && VB_MOD="virtualbox-guest-modules"
        
			dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_VBoxInstTitle" --msgbox "$_VBoxInstBody" 0 0
            clear
 			
            pacstrap ${MOUNTPOINT} virtualbox-guest-utils ${VB_MOD} 2>/tmp/.errlog
 
            # Load modules and enable vboxservice.
            arch_chroot "modprobe -a vboxguest vboxsf vboxvideo"  
            arch_chroot "systemctl enable vboxservice"
            echo -e "vboxguest\nvboxsf\nvboxvideo" > ${MOUNTPOINT}/etc/modules-load.d/virtualbox.conf
             ;;
        "9") # VMWare
			pacstrap ${MOUNTPOINT} xf86-video-vmware xf86-input-vmmouse 2>/tmp/.errlog
             ;;
       "10") # Generic / Unknown
			  pacstrap ${MOUNTPOINT} xf86-video-fbdev 2>/tmp/.errlog
             ;;
          *) install_desktop_menu
             ;;
    esac
    check_for_error

 # Create a basic xorg configuration file for NVIDIA proprietary drivers where installed
 # if that file does not already exist.
 if [[ $NVIDIA_INST == 1 ]] && [[ ! -e ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf ]]; then
    echo "Section "\"Device"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        Identifier "\"Nvidia Card"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        Driver "\"nvidia"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        VendorName "\"NVIDIA Corporation"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        Option "\"NoLogo"\" "\"true"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        #Option "\"UseEDID"\" "\"false"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        #Option "\"ConnectedMonitor"\" "\"DFP"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "        # ..." >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo "EndSection" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
 fi
 
 # Where NVIDIA has been installed allow user to check and amend the file
 if [[ $NVIDIA_INST == 1 ]]; then
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NvidiaConfTitle" --msgbox "$_NvidiaConfBody" 0 0
    nano ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
 fi

}


install_de_wm() {

   # Only show this information box once
   if [[ $SHOW_ONCE -eq 0 ]]; then
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstDETitle" --msgbox "$_DEInfoBody" 0 0
      SHOW_ONCE=1
   fi

	# DE/WM Menu
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstDETitle" --checklist "$_InstDEBody $_UseSpaceBar" 0 0 12 \
	"cinnamon" "-" off \
	"deepin" "-" off \
	"deepin-extra" "-" off \
	"enlightenment + terminology" "-" off \
	"gnome-shell" "-" off \
	"gnome" "-" off \
	"gnome-extra" "-" off \
	"plasma-desktop" "-" off \
	"plasma" "-" off \
	"kde-applications" "-" off \
	"lxde" "-" off \
	"lxqt + oxygen-icons" "-" off \
	"mate" "-" off \
	"mate-extra" "-" off \
	"mate-gtk3" "-" off \
	"mate-extra-gtk3" "-" off \
	"xfce4" "-" off \
	"xfce4-goodies" "-" off \
	"awesome + vicious" "-" off \
	"fluxbox + fbnews" "-" off \
	"i3-wm + i3lock + i3status" "-" off \
	"icewm + icewm-themes" "-" off \
	"openbox + openbox-themes" "-" off \
	"pekwm + pekwm-themes" "-" off \
	"windowmaker" "-" off 2>${PACKAGES}

	# If something has been selected, install
	if [[ $(cat ${PACKAGES}) != "" ]]; then
		clear
		sed -i 's/+\|\"//g' ${PACKAGES}
		pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
		check_for_error

		
		# Clear the packages file for installation of "common" packages
		echo "" > ${PACKAGES}

		# Offer to install various "common" packages.
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstComTitle" --checklist "$_InstComBody $_UseSpaceBar" 0 50 14 \
		"bash-completion" "-" on \
		"gamin" "-" on \
		"gksu" "-" on \
		"gnome-icon-theme" "-" on \
		"gnome-keyring" "-" on \
		"gvfs" "-" on \
		"gvfs-afc" "-" on \
		"gvfs-smb" "-" on \
		"polkit" "-" on \
		"python2-xdg" "-" on \
		"ntfs-3g" "-" on \
		"ttf-dejavu" "-" on \
		"xdg-user-dirs" "-" on \
		"xdg-utils" "-" on \
		"xterm" "-" on 2>${PACKAGES}

		# If at least one package, install.
		if [[ $(cat ${PACKAGES}) != "" ]]; then
			clear
			pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
			check_for_error
		fi

	fi

}

# First see if selected
install_dm() {

	if [[ $DM_INSTALLED -eq 0 ]]; then
		# Prep variables
		echo "" > ${PACKAGES}
		echo "" > ${DM_INST}
		dm_list="gdm lxdm lightdm sddm"
		DM_LIST=""

		# Generate list of DMs installed with DEs, and a list for selection menu
		for i in ${dm_list[@]}; do
			[[ -e ${MOUNTPOINT}/usr/share/${i} ]] && echo ${i} >> $DM_INST
			DM_LIST="${DM_LIST} ${i} -"
		done

		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmChTitle" --menu "$_AlreadyInst$(cat $DM_INST)\n\n$_DmChBody" 0 0 5 ${DM_LIST} 2>${PACKAGES}
		clear
		
		# If a selection has been made, act
		if [[ $(cat ${PACKAGES}) != "" ]]; then
		
			# check if selected dm already installed. If so, enable and break loop.
			for i in $(cat ${DM_INST[@]}); do
				if [[ $(cat ${PACKAGES}) == ${i} ]]; then 
					arch_chroot "systemctl enable $(cat ${PACKAGES})" >/dev/null 2>/tmp/.errlog
					check_for_error
					DM_INSTALLED=1
					break;
				fi
			done
		
			# If no match found, install and enable DM	
			if [[ $DM_INSTALLED -eq 0 ]]; then
		
				# Where lightdm selected, add gtk greeter package
				sed -i 's/lightdm/lightdm lightdm-gtk-greeter/' ${PACKAGES}
				pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
			
				# Where lightdm selected, now remove the greeter package
				sed -i 's/lightdm-gtk-greeter//' ${PACKAGES}
				arch_chroot "systemctl enable $(cat ${PACKAGES})" >/dev/null 2>/tmp/.errlog
				check_for_error
				DM_INSTALLED=1	
			fi
		fi
	fi

	# Show after successfully installing or where attempting to repeat when already completed.
	[[ $DM_INSTALLED -eq 1 ]] && dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmChTitle" --msgbox "$_DmDoneBody" 0 0       
}

install_nm() {

   # Check to see if a NM has already been installed and enabled
	if [[ $NM_INSTALLED -eq 0 ]]; then

		echo "" > ${PACKAGES}
		NM_INST=""
		[[ -e ${MOUNTPOINT}/usr/bin/NetworkManager ]] && NM_INST="networkmanager"

		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstNMTitle" --menu "$_AlreadyInst $NM_INST\n\n$_InstNMBody" 0 0 4 \
		"connman" "(CLI)" \
		"dhcpcd"  "(CLI)" \
		"networkmanager" "(GUI)" \
		"wicd" "(GUI)" 2> ${PACKAGES}	
		clear

		# If a selection has been made, act
		if [[ $(cat ${PACKAGES}) != "" ]]; then
		
			# check if selected nm already installed. If so, enable.
			if [[ $(cat ${PACKAGES}) == $NM_INST ]]; then
				arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service" 2>/tmp/.errlog
				check_for_error
                NM_INSTALLED=1
            fi
            
			# If no match found, install and enable NM	
			if [[ $NM_INSTALLED -eq 0 ]]; then
			 
				# Where networkmanager selected, add network-manager-applet
				sed -i 's/networkmanager/networkmanager network-manager-applet/' ${PACKAGES}
				pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
			
				# Where networkmanager selected, now change for systemctl enable command
				sed -i 's/networkmanager network-manager-applet/NetworkManager \&\& systemctl enable NetworkManager-dispatcher/g' ${PACKAGES}
				arch_chroot "systemctl enable $(cat ${PACKAGES})" 2>>/tmp/.errlog
				check_for_error
				NM_INSTALLED=1
			fi
		fi
	fi
	
	# Show after successfully installing or where attempting to repeat when already completed.
	[[ $NM_INSTALLED -eq 1 ]] && dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstNMTitle" --msgbox "$_InstNMErrBody" 0 0

}

######################################################################
##																	##
##                 Main Interfaces       							##
##																	##
######################################################################

# Greet the user when first starting the installer
greeting() {

dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WelTitle $VERSION " --msgbox "$_WelBody" 0 0	

}

# Preparation
prep_menu() {
	
	if [[ $SUB_MENU != "prep_menu" ]]; then
	   SUB_MENU="prep_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 7 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi
	
   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PrepTitle" \
    --menu "$_PrepBody" 0 0 7 \
 	"1" "$_ConfBseVirtCon" \
	"2" "$_PrepMirror" \
	"3" "$_DevShowOpt" \
	"4" "$_PrepPartDisk" \
	"5" "$_PrepLVM" \
	"6" "$_PrepMntPart" \
	"7" "$_Back" 2>${ANSWER}

    HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") set_keymap 
             ;;
        "2") configure_mirrorlist
             ;;
        "3") show_devices
             ;;
        "4") umount_partitions
             select_device
             create_partitions
             ;;
        "5") detect_lvm
             deactivate_lvm
             find_lvm_partitions
             create_lvm
             ;;
        "6") mount_partitions
             ;;        
          *) main_menu_online
             ;;
    esac
    
    prep_menu  	
	
}

# Base Installation
install_base_menu() {

	if [[ $SUB_MENU != "install_base_menu" ]]; then
	   SUB_MENU="install_base_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 5 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBsMenuTitle" --menu "$_InstBseMenuBody" 0 0 5 \
 	"1" "$_PrepPacKey" \
 	"2" "$_InstBse" \
	"3" "$_InstBootldr" \
	"4" "$_WirelssOptTitle" \
	"5" "$_Back" 2>${ANSWER}	
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") clear
             pacman-key --init
             pacman-key --populate archlinux
             pacman-key --refresh-keys
             ;;
        "2") install_base
             ;;
        "3") install_bootloader
             ;;
        "4") install_wireless_packages
             ;;
          *) main_menu_online
             ;;
     esac
    
    install_base_menu 	
}

# Base Configuration
config_base_menu() {
	
	# Set the default PATH variable
    arch_chroot "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog
	check_for_error
	
	if [[ $SUB_MENU != "config_base_menu" ]]; then
	   SUB_MENU="config_base_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 7 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ConfBseTitle" --menu "$_ConfBseBody" 0 0 7 \
 	"1" "$_ConfBseFstab" \
	"2" "$_ConfBseHost" \
	"3" "$_ConfBseTime" \
	"4" "$_ConfBseHWC" \
	"5" "$_ConfBseSysLoc" \
	"6" "$_PrepKBLayout" \
	"7" "$_Back" 2>${ANSWER}	
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") generate_fstab 
             ;;
        "2") set_hostname
             ;;
        "3") set_timezone
             ;;
        "4") set_hw_clock
             ;;            
        "5") set_locale
             ;;
        "6") set_xkbmap
             ;;           
          *) main_menu_online
             ;;
    esac
    
    config_base_menu

}

# Root and User Configuration
config_user_menu() {

	if [[ $SUB_MENU != "config_user_menu" ]]; then
	   SUB_MENU="config_user_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 3 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ConfUsrTitle" --menu "$_ConfUsrBody" 0 0 3 \
 	"1" "$_ConfUsrRoot" \
	"2" "$_ConfUsrNew" \
	"3" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
    case $(cat ${ANSWER}) in
    "1") set_root_password 
         ;;
    "2") create_new_user
         ;;     
      *) main_menu_online
         ;;
    esac
    
    config_user_menu
}


install_desktop_menu() {

	if [[ $SUB_MENU != "install_deskop_menu" ]]; then
	   SUB_MENU="install_deskop_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 5 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstDEMenuTitle" --menu "$_InstDEMenuBody" 0 0 5 \
 	"1" "$_InstDEMenuGISD" \
	"2" "$_InstDEMenuDE" \
	"3" "$_InstDEMenuNM" \
	"4" "$_InstDEMenuDM" \
	"5" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") [[ AXI_INSTALLED -eq 0 ]] && install_alsa_xorg_input
             setup_graphics_card 
             ;;
        "2") install_de_wm
             ;;
        "3") install_nm
             ;;
        "4") install_dm
             ;;            
          *) main_menu_online
             ;;
    esac
    
    install_desktop_menu
	
}

# Install Accessibility Applications
install_acc_menu() {

	echo "" > ${PACKAGES}

	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstAccTitle" --checklist "$_InstAccBody" 0 0 15 \
	"accerciser" "-" off \
	"at-spi2-atk" "-" off \
	"at-spi2-core" "-" off \
	"brltty" "-" off \
	"caribou" "-" off \
	"dasher" "-" off \
	"espeak" "-" off \
	"espeakup" "-" off \
	"festival" "-" off \
	"java-access-bridge" "-" off \
	"java-atk-wrapper" "-" off \
	"julius" "-" off \
	"orca" "-" off \
	"qt-at-spi" "-" off \
	"speech-dispatcher" "-" off 2>${PACKAGES}
	
	clear
	# If something has been selected, install
	if [[ $(cat ${PACKAGES}) != "" ]]; then
		pacstrap ${MOUNTPOINT} ${PACKAGES} 2>/tmp/.errlog
		check_for_error
	fi

}


edit_configs() {
	
	# Clear the file variables
	FILE=""
	FILE2=""
	user_list=""
	
	if [[ $SUB_MENU != "edit configs" ]]; then
	   SUB_MENU="edit configs"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 10 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SeeConfOptTitle" --menu "$_SeeConfOptBody" 0 0 10 \
   "1" "/etc/vconsole.conf" \
   "2" "/etc/locale.conf" \
   "3" "/etc/hostname" \
   "4" "/etc/hosts" \
   "5" "/etc/sudoers" \
   "6" "/etc/mkinitcpio.conf" \
   "7" "/etc/fstab" \
   "8" "sys" \
   "9" "$DM" \
   "10" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
	    "1") FILE="${MOUNTPOINT}/etc/vconsole.conf"
             ;;
        "2") FILE="${MOUNTPOINT}/etc/locale.conf" 
             ;;
        "3") FILE="${MOUNTPOINT}/etc/hostname"
             ;;
        "4") FILE="${MOUNTPOINT}/etc/hosts"
             ;;
        "5") FILE="${MOUNTPOINT}/etc/sudoers"
             ;;
        "6") FILE="${MOUNTPOINT}/etc/mkinitcpio.conf"
             ;;
        "7") FILE="${MOUNTPOINT}/etc/fstab"
             ;;
        "8") FILE="${MOUNTPOINT}/boot/syslinux/syslinux.cfg"
        #case $BOOTLOADER in
         #          "Grub") FILE="${MOUNTPOINT}/etc/default/grub"
         #                  ;;
         #      "Syslinux") FILE="${MOUNTPOINT}/boot/syslinux/syslinux.cfg"
         #                  ;;
         #  "systemd-boot") FILE="${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf" 
         #                  FILE2="${MOUNTPOINT}${UEFI_MOUNT}/loader/loader.conf"
         #                  ;;
         #        "rEFInd") [[ -e ${MOUNTPOINT}${UEFI_MOUNT}/EFI/refind/refind.conf ]] \
         #                  && FILE="${MOUNTPOINT}${UEFI_MOUNT}/EFI/refind/refind.conf" || FILE="${MOUNTPOINT}${UEFI_MOUNT}/EFI/BOOT/refind.conf"
         #                  FILE2="${MOUNTPOINT}/boot/refind_linux.conf"
         #                  ;;
         #     esac
            ;;
        "9") case $DM in
                   "LXDM") FILE="${MOUNTPOINT}/etc/lxdm/lxdm.conf" 
                           ;;
                "LightDM") FILE="${MOUNTPOINT}/etc/lightdm/lightdm.conf" 
                           ;;
                   "SDDM") FILE="${MOUNTPOINT}/etc/sddm.conf"
                           ;;
                   "SLiM") FILE="${MOUNTPOINT}/etc/slim.conf"
                           ;;
              esac
            ;;       
         *) main_menu_online
            ;;
     esac
     
        # open file(s) with nano   
        if [[ -e $FILE ]] && [[ $FILE2 != "" ]]; then
           nano $FILE $FILE2
        elif [[ -e $FILE ]]; then 
           nano $FILE
        else
           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SeeConfErrTitle" --msgbox "$_SeeConfErrBody1" 0 0
        fi
     
     edit_configs
}

main_menu_online() {
	
	if [[ $HIGHLIGHT != 8 ]]; then
	   HIGHLIGHT=$(( HIGHLIGHT + 1 ))
	fi
	
    dialog --default-item ${HIGHLIGHT} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MMTitle" \
    --menu "$_MMBody" 0 0 9 \
 	"1" "$_MMPrep" \
	"2" "$_MMInstBse" \
	"3" "$_MMConfBse" \
	"4" "$_MMConfUsr" \
	"5" "$_MMInstDE" \
	"6" "$_InstAccOpt" \
    "7" "$_MMRunMkinit" \
    "8" "$_SeeConfOpt" \
	"9" "$_Done" 2>${ANSWER}

    HIGHLIGHT=$(cat ${ANSWER})
    
    # Depending on the answer, first check whether partition(s) are mounted and whether base has been installed
    if [[ $(cat ${ANSWER}) -eq 2 ]]; then
       check_mount
    fi

    if [[ $(cat ${ANSWER}) -ge 3 ]] && [[ $(cat ${ANSWER}) -le 7 ]]; then
       check_mount
       check_base
    fi
    
    case $(cat ${ANSWER}) in
        "1") prep_menu 
             ;;
        "2") install_base_menu
             ;;
        "3") config_base_menu
             ;;
        "4") config_user_menu
             ;;            
        "5") install_desktop_menu
             ;;
        "6") install_acc_menu
             ;;
        "7") run_mkinitcpio
             ;;
        "8") edit_configs
             ;;            
          *) dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --yesno "$_CloseInstBody" 0 0
          
             if [[ $? -eq 0 ]]; then
                umount_partitions
                clear
                exit 0
             else
                main_menu_online
             fi
             
             ;;
    esac
    
    main_menu_online 
    
}

######################################################################
##																	##
##                        Execution     							##
##																	##
######################################################################
id_system
dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Development Installer Warning " --msgbox "\nWARNING: This Development branch of the Architect installer is currently being re-coded. During this process functions may not work properly or even at all.\n\nPlease use the STABLE branch by closing the installer and rebooting, or by selecting the 'Virtual Console' option, and then entering /initialise at the command prompt to start again.\n\nOtherwise, proceed at your own risk.\n" 0 0
select_language
check_requirements
greeting

	while true; do
          main_menu_online      
    done
